Readme for Bottlenose NTP coding project

There are essentially two versions of this project. I was confused by the instructions (specifically the part which states "the goal of this exercise is to write a SINGLE program which contains a Producer and multiple Consumers"). I didn't quite understand the exercise, but wrote a program (NTPserver.js) that creates Producer and Consumer objects and has them send messages to each other. However, after emailing with Damon, I came to the conclusion that the idea was actually to write a server and a client that run independently. As a result, I rewrote my code entirely. The previous verion of the project can be seen in commit: __________.

This version of the project has 3 programs, udpServer.js, udpClient.js and manageClients.js. udpServer.js creates the producer server and sends out time messages 1/second to all clients that have connected to it. It also waits for keepAlive messages and disconnects any client that hasn't sent a keepAlive message in the last 10 seconds. udpClient.js creates a single instance of a customer. This customer has a randomly generated value between 0-12 that governs how many "keepAlive" messages it will send. manageClients.js is a simple program that takes a command line argument and creates that many instances of a consumer.

The producer is very simple. It broadcasts the time to all of its receipients every second under the server is killed (w/ CTRL + C). It also maintains two lists; the first is a list of the port numbers of all of the customers connected to it and the second is an object that stores the port number of a customer and the remaining time that customer will be alive as a key-value pair. In the broadcast loop, each customer is looked up by port number and the remaining time value is decremented. If the value is > 0, the normal time message is sent to the client with a 0 appended to the beginning of the message. If the value == 0, then a message with the prefix 1 is sent to the customer.

Upon receiving a message, the customer looks at the prefix. If the prefix is 0, it prints the message to console along with the port it is receiving the message on. (I interpreted this as the desired "identifier of the thread the Consumer is running in." Alternatively, if different processes were actually desired for each Consumer, a simple script could be written to fork a modified version of the manageClients program to generate Customers who were actually running on different threads. At this point, their pid's would be the unique identifier.) If the prefix is 1, the customer closes its connection and then clears its interval timer.

The customer also sends two types of messages. When it is created, it sends a registration message - a message prefixed by a 0 to the producer. It also sends k keepAlive messages on 5 second intervals - this message is a 1 and the intervalID. When the producer receives a message with a 0, it adds that customer to the lists it curates as described above. When it receives a message of a 1, it resets the timer on that Consumer's port number to 10 seconds. 


